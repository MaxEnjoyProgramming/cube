#!/usr/bin/env node
var debug = require('debug')('cube:cli');
var cmd = require('commander');
var Cube = require('../index');
var fs = require('xfs');
var path = require('path');
var pkg = require(path.join(__dirname, '../package'));
var childProcess = require('child_process');

function getCwd() {
  return process.cwd();
}
/** find cube.js **/
function findCube(cb) {
  var base = getCwd();
  debug('find cube file: %s', base);
  var tar = [];
  fs.walk(base, function (err, file) {
    if (/(\/node_modules\/|\/\.git)/.test(file)) {
      return ;
    }
    var filename = path.basename(file);
    if (/^cube\.(min\.)?js$/.test(filename)) {
      tar.push(file);
    }
  }, function () {
    if (tar.length > 1) {
      console.log('[ERROR] more then one cube founded!', tar);
      return cb(null);
    } else if (!tar.length) {
      console.log('[]ERROR] cube not found');
      return cb(null);
    }
    cb(tar[0]);
  });
}

function optmizeInfo() {
  console.log('[INFO] you can custom cube.min.js file, i.e : css_runtime');
}

function filePath(file) {
  var base = getCwd();
  return path.join(base, file);
}

function sourcePath(file) {
  var base = __dirname;
  return path.join(base, '../', file);
}

function buildOutput(err, info) {
  console.log('==================');
  if (err.length) {
    err.forEach(function (e) {
      console.log('\t*', e.code, e.message);
    });
  } else {
    console.log('Build successfully');
  }
  console.log('==================');
  console.log(err.length ? 'Build Finished, Total Errors: ' + err.length :  ' Build Successfully');
  console.log('Files:', info.total, 'Cost:', info.time + 's');
  console.log('==================');
}

cmd.version('v' + pkg.version);


cmd.command('start [path]', 'start server, if path is not giving');
cmd.command('init', 'init project');

cmd.command('install')
  .description('install dependences')
  .action(function (option, dir) {
    dir = dir ? filePath(dir) : getCwd();
    var out = childProcess.execSync('npm3 -v').toString().trim();
    var m = out.match(/(\d+)\.(\d+)\.(\d+)/);
    if (!m) {
      console.log('[Error] npm3 not installed');
      console.log('using this cmd:  npm install -g npm3');
      process.exit(1);
    }
    childProcess.execSync('npm3 install');
  });

cmd.command('update')
  .description('update cube.min.js')
  .option('-a, --all', 'simple cube.min.js, no other run_time inculde')
  .action(function (option) {
    findCube(function (cubeFile) {
      if (!cubeFile) {
        return;
      }
      var codeCube = '//cube.min.js\n' + fs.readFileSync(sourcePath('./runtime/cube.min.js')).toString();
      if (option.all) {
        console.log('enabled jade');
        codeCube += '\n//jade_runtime\n' + fs.readFileSync(sourcePath('./runtime/jade_runtime.min.js'));
        console.log('enabled ejs');
        codeCube += '\n//ejs_runtime\n' + fs.readFileSync(sourcePath('./runtime/ejs_runtime.min.js'));
        optmizeInfo();
      }
      fs.sync().save(cubeFile, codeCube);
      console.log(cubeFile, 'updated');
    });
  });

function isAbsPath(p) {
  if (process.platform.indexOf('win') === 0) {
    return /^\w:/.test(p);
  } else {
    return /^\//.test(p);
  }
}

cmd.command('build')
  /**
   * source , -o,--output, -b, --base 是基于cwd路径, 互相之间没有依赖关系
   */
  .usage('-p processor1,processor2 your_code_dir')
  .description('build the hole project, including: less->css->min, script->wraped->min')
  .option('-p, --processors [value]', 'loading plugin processors, like `cube-coffee,cube-jsx`')
  .option('-o, --output [value]', 'set the output path')
  .option('-b, --base [value]', 'set the cube base')
  .option('-r, --resbase [value]', 'the http base for resouce')
  .option('--remote [value]', 'set the namespace for remote call')
  .option('--merge', 'if merged dependences into on file')
  .option('--with-source', 'create source file')
  .option('--without-compress', 'do not compress code, output the source with wrap')
  .action(function (source, args) {
    if (!args || !source) {
      this.help();
      return;
    }
    if (args.processors) {
      args.processors = args.processors.split(',');
      args.processors.forEach(function (v, i, a) {
        a[i] = v.trim();
      });
    }

    var cwd = getCwd();
    var fstat;
    var inputPath, outputPath, cube, tool, root;
    var compress = args.withoutCompress ? false : true;

    root = args.base ? args.base : '';
    if (root) {
      root = isAbsPath(root) ? root : path.join(cwd, root);
    }
    source = isAbsPath(source) ? source : path.join(cwd, source);
    inputPath = source;
    try {
      fstat = fs.statSync(source);
    } catch (e) {
      console.log('source not fould', e);
      this.help();
      return;
    }

    if (fstat.isFile()) {
      outputPath = args.output ? (isAbsPath(args.output) ? args.output : path.join(cwd, args.output)) : source.replace(/\.(\w+)$/, '.min.$1');
      root = (root ? root : path.dirname(source)).replace(/(\/|\\)$/, '');
      cube = new Cube({
        release: true,
        root: root,
        compress: compress,
        middleware: false,
        processors: args.processors,
        resBase: args.resbase,
        remote: args.remote
      });
      tool = Cube.getTool();
      tool.processFile(cube, source, outputPath, {withSource: args.withSource}, buildOutput);
    } else if (fstat.isDirectory()) {
      outputPath = args.output ? (isAbsPath(args.output) ? args.output : path.join(cwd, args.output)) : (source.replace(/(\/|\\)$/, '') + '.release');
      root = (root ? root : source).replace(/(\/|\\)$/, '');
      cube = new Cube({
        release: true,
        root: root,
        compress: compress,
        middleware: false,
        processors: args.processors,
        resBase: args.resbase,
        remote: args.remote
      });
      tool = Cube.getTool();
      tool.processDir(cube, inputPath, outputPath, {withSource: args['with-source']}, buildOutput);
    } else {
      console.log('unknow type input source', source);
    }
  });

/**
 * build into single file
 */
cmd.command('all-in-one')
  .usage('-p processor1,processor2 your_file')
  .option('-o, --output [value]', 'output file')
  .option('-b, --base [value]', 'set dir base')
  .option('-r, --resbase [value]', 'resource base')
  .action(function (source, args) {
    if (!args || !source) {
      return this.help();
    }
    if (args.processors) {
      args.processors = args.processors.split(',');
      args.processors.forEach(function (v, i, a) {
        a[i] = v.trim();
      });
    }

    var cwd = getCwd();
    var outputPath, cube, tool, root;
    var compress = true;
    var fstat;
    root = args.base ? args.base : '';
    if (root) {
      root = isAbsPath(root) ? root : path.join(cwd, root);
    }
    source = isAbsPath(source) ? source : path.join(cwd, source);
    try {
      fstat = fs.statSync(source);
    } catch (e) {
      console.log('source not fould', e);
      this.help();
      return;
    }
    if (fstat.isDirectory()) {
      console.log('proess file only');
      return ;
    }
    outputPath = args.output ? (isAbsPath(args.output) ? args.output : path.join(cwd, args.output)) : source.replace(/\.(\w+)$/, '.release');
    root = (root ? root : path.dirname(source)).replace(/(\/|\\)$/, '');
    cube = new Cube({
      release: true,
      root: root,
      compress: compress,
      middleware: false,
      processors: args.processors,
      resBase: args.resbase,
      remote: args.remote
    });
    tool = Cube.getTool();
    var codes = [];
    var styles = [];
    var infos = [];
    var codesMap = {};
    var indent = 0;
    function _cb(err, res, i) {
      if (err.length) {
        err.forEach(function () {

        });
        return ;
      }
      var result = res.result;
      if (codesMap[result.file]) {
        return;
      }
      codesMap[result.file] = true;
      if (result.type === 'style') {
        styles.push(result.code);
      } else {
        codes.unshift(result.type !== 'script' ? result.wraped : result.code);
      }
      infos.push(fmtInfo(i, result.file));
      if (result.originalRequires) {
        var n = i + 1;
        result.originalRequires.forEach(function (m) {
          if (!fs.existsSync(path.join(root, m))) {
            return console.error('[error] missing require:', m);
          }
          if (codesMap[m]) {
            return;
          }

          tool.processFile(cube, path.join(root, m), null, {}, function (err, data) {
            _cb(err, data, n);
          });
        });
      }
    }
    tool.processFile(cube, source, null, {}, function (err, data) {
      _cb(err, data, indent);
    });
    codes.unshift('var Cube = g.Cube;');
    codes.unshift(fs.readFileSync(path.join(__dirname, '../runtime/cube.min.js')).toString().replace('window,null', 'g,null'));
    codes.unshift('!(function(host, propName){\nvar g = {};');
    codes.push('Cube.use("' + infos[0] + '", function(mod) { host[propName] = mod;});');
    codes.push('})(host, "cubeExports")');
    fs.sync().save(path.join(outputPath, '/script.js'), codes.join('\n'));
    fs.sync().save(path.join(outputPath, '/style.css'), styles.join('\n'));
    console.log('===== deps =====');
    console.log(infos.join('\n'));
    console.log('======');
    console.log('output dir:', outputPath);
    console.log('======');
  });

function fmtInfo(indent) {
  var args = [].slice.call(arguments, 1);
  var str = [];
  for (var i = 0 ; i < indent ; i ++) {
    str.push('    ');
  }
  args.unshift(str.join(''));
  return args.join('');
}

/**
 * build工程目录，并进行自动合并优化
 * node_modules目录将进行选择性build
 */
cmd.command('smart-build')
  /**
   * source , -o,--output, -b, --base 是基于cwd路径, 互相之间没有依赖关系
   */
  .usage('-p processor1,processor2 your_code_dir')
  .description('single build the hole project, including: less->css->min, script->wraped->min')
  .option('-p, --processors [value]', 'loading plugin processors, like `cube-coffee,cube-jsx`')
  .option('-o, --output [value]', 'set the output path')
  .option('-b, --base [value]', 'set the cube base')
  .option('-r, --resbase [value]', 'the http base for resouce')
  .option('--remote [value]', 'set the namespace for remote call')
  .option('--auto-merge', 'if switch on auto-merge deps')
  .option('--without-compress', 'do not compress code, output the source with wrap')
  .action(function (source, args) {
    if (!args || !source) {
      return this.help();
    }
    if (args.processors) {
      args.processors = args.processors.split(',');
      args.processors.forEach(function (v, i, a) {
        a[i] = v.trim();
      });
    }

    var cwd = getCwd();
    var fstat;
    var inputPath, outputPath, cube, tool, root;
    var compress = args.withoutCompress ? false : true;

    root = args.base ? args.base : '';
    if (root) {
      root = isAbsPath(root) ? root : path.join(cwd, root);
    }
    source = isAbsPath(source) ? source : path.join(cwd, source);
    inputPath = source;
    try {
      fstat = fs.statSync(source);
    } catch (e) {
      console.log('source not fould', e);
      this.help();
      return;
    }

    if (fstat.isFile()) {
      outputPath = args.output ? (isAbsPath(args.output) ? args.output : path.join(cwd, args.output)) : source.replace(/\.(\w+)$/, '.min.$1');
      root = (root ? root : path.dirname(source)).replace(/(\/|\\)$/, '');
      cube = new Cube({
        release: true,
        root: root,
        compress: compress,
        middleware: false,
        processors: args.processors,
        resBase: args.resbase,
        remote: args.remote
      });
      tool = Cube.getTool();
      tool.processFile(cube, source, outputPath, {withSource: args.withSource}, buildOutput);
    } else if (fstat.isDirectory()) {
      outputPath = args.output ? (isAbsPath(args.output) ? args.output : path.join(cwd, args.output)) : (source.replace(/(\/|\\)$/, '') + '.release');
      root = (root ? root : source).replace(/(\/|\\)$/, '');
      cube = new Cube({
        release: true,
        root: root,
        compress: compress,
        middleware: false,
        processors: args.processors,
        resBase: args.resbase,
        remote: args.remote
      });
      tool = Cube.getTool();
      tool.processDir(cube, inputPath, outputPath, {withSource: args['with-source']}, buildOutput);
    } else {
      console.log('unknow type input source', source);
    }
  });

/*
cmd.command('dag')
  .usage('your_code_dir')
  .description('gen DAG graph')
  .action(function (tar) {
    var source = path.join(getCwd(), tar);
    if (/(\/|\\)$/.test(source)) {
      source = source.substr(0, source.length - 1);
    }
    var stat = fs.statSync(source);
    var root;
    var flagFile = false;
    if (stat.isFile()) {
      flagFile = true;
      root = path.dirname(source);
    } else {
      root = source;
    }
    var cube = new Cube({
      root: root
    });
    var processor = new JsProcessor(cube);

    // var stat = fs.statSync(source);
    if (flagFile) {
      source = path.basename(source);
      processor.process(source, {root: root, moduleWrap: true}, function () {
        end();
      });
    } else {
      fs.walk(source, /\.(js|coffee|jsx)$/, function (err, file, done) {
        if (err) {
          console.log('make dag error', err);
          process.exit(1);
        }
        file = file.substr(root.length);
        processor.process(file, {root: root, moduleWrap: true}, function () {
          done();
        });
      }, end);
    }

    function end() {
      // done
      var requires = JsProcessor.requires;
      var res = [];
      // {source: "Samsung", target: "Apple", type: "suit"}
      for (var i in requires) {
        requires[i].forEach(function (v) {
          res.push({source: i, target: v, type: 'suit'});
        });
      }
      var fstr = fs.readFileSync(path.join(__dirname, '../res/dag.html')).toString();
      fstr = fstr.replace(/\$\$\$_\$\$\$/, JSON.stringify(res));
      fs.sync().save(path.join(root, './dag_out.html'), fstr);
      console.log('browser open: ' + root + '/dag_out.html');
    }
  });
*/

cmd.command('help')
  .description('help')
  .action(function () {
    cmd.help();
  });

cmd.parse(process.argv);

if (!cmd.args.length) {
  cmd.help();
}
